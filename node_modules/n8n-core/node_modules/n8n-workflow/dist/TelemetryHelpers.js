"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNodesGraph = exports.getDomainPath = exports.ANONYMIZATION_CHARACTER = exports.getDomainBase = exports.isNumber = exports.getNodeTypeForName = void 0;
const NodeHelpers_1 = require("./NodeHelpers");
const application_error_1 = require("./errors/application.error");
const Constants_1 = require("./Constants");
function getNodeTypeForName(workflow, nodeName) {
    return workflow.nodes.find((node) => node.name === nodeName);
}
exports.getNodeTypeForName = getNodeTypeForName;
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
function areOverlapping(topLeft, bottomRight, targetPos) {
    return (targetPos[0] > topLeft[0] &&
        targetPos[1] > topLeft[1] &&
        targetPos[0] < bottomRight[0] &&
        targetPos[1] < bottomRight[1]);
}
const URL_PARTS_REGEX = /(?<protocolPlusDomain>.*?\..*?)(?<pathname>\/.*)/;
function getDomainBase(raw, urlParts = URL_PARTS_REGEX) {
    var _a;
    try {
        const url = new URL(raw);
        return [url.protocol, url.hostname].join('//');
    }
    catch {
        const match = urlParts.exec(raw);
        if (!((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.protocolPlusDomain))
            return '';
        return match.groups.protocolPlusDomain;
    }
}
exports.getDomainBase = getDomainBase;
function isSensitive(segment) {
    if (/^v\d+$/.test(segment))
        return false;
    return /%40/.test(segment) || /\d/.test(segment) || /^[0-9A-F]{8}/i.test(segment);
}
exports.ANONYMIZATION_CHARACTER = '*';
function sanitizeRoute(raw, check = isSensitive, char = exports.ANONYMIZATION_CHARACTER) {
    return raw
        .split('/')
        .map((segment) => (check(segment) ? char.repeat(segment.length) : segment))
        .join('/');
}
function getDomainPath(raw, urlParts = URL_PARTS_REGEX) {
    var _a;
    try {
        const url = new URL(raw);
        if (!url.hostname)
            throw new application_error_1.ApplicationError('Malformed URL');
        return sanitizeRoute(url.pathname);
    }
    catch {
        const match = urlParts.exec(raw);
        if (!((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.pathname))
            return '';
        const route = match.groups.pathname.split('?').shift();
        return sanitizeRoute(route);
    }
}
exports.getDomainPath = getDomainPath;
function generateNodesGraph(workflow, nodeTypes, options) {
    var _a, _b, _c, _d;
    const nodeGraph = {
        node_types: [],
        node_connections: [],
        nodes: {},
        notes: {},
        is_pinned: Object.keys((_a = workflow.pinData) !== null && _a !== void 0 ? _a : {}).length > 0,
    };
    const nameIndices = {};
    const webhookNodeNames = [];
    const notes = ((_b = workflow.nodes) !== null && _b !== void 0 ? _b : []).filter((node) => node.type === Constants_1.STICKY_NODE_TYPE);
    const otherNodes = ((_c = workflow.nodes) !== null && _c !== void 0 ? _c : []).filter((node) => node.type !== Constants_1.STICKY_NODE_TYPE);
    notes.forEach((stickyNote, index) => {
        var _a;
        const stickyType = nodeTypes.getByNameAndVersion(Constants_1.STICKY_NODE_TYPE, stickyNote.typeVersion);
        if (!stickyType) {
            return;
        }
        const nodeParameters = (_a = (0, NodeHelpers_1.getNodeParameters)(stickyType.description.properties, stickyNote.parameters, true, false, stickyNote)) !== null && _a !== void 0 ? _a : {};
        const height = typeof nodeParameters.height === 'number' ? nodeParameters.height : 0;
        const width = typeof nodeParameters.width === 'number' ? nodeParameters.width : 0;
        const topLeft = stickyNote.position;
        const bottomRight = [topLeft[0] + width, topLeft[1] + height];
        const overlapping = Boolean(otherNodes.find((node) => areOverlapping(topLeft, bottomRight, node.position)));
        nodeGraph.notes[index] = {
            overlapping,
            position: topLeft,
            height,
            width,
        };
    });
    otherNodes.forEach((node, index) => {
        var _a, _b, _c, _d, _e, _f;
        nodeGraph.node_types.push(node.type);
        const nodeItem = {
            id: node.id,
            type: node.type,
            version: node.typeVersion,
            position: node.position,
        };
        if (options === null || options === void 0 ? void 0 : options.sourceInstanceId) {
            nodeItem.src_instance_id = options.sourceInstanceId;
        }
        if (node.id && ((_a = options === null || options === void 0 ? void 0 : options.nodeIdMap) === null || _a === void 0 ? void 0 : _a[node.id])) {
            nodeItem.src_node_id = options.nodeIdMap[node.id];
        }
        if (node.type === Constants_1.AGENT_LANGCHAIN_NODE_TYPE) {
            nodeItem.agent = node.parameters.agent || 'conversationalAgent';
        }
        else if (node.type === Constants_1.HTTP_REQUEST_NODE_TYPE && node.typeVersion === 1) {
            try {
                nodeItem.domain = new URL(node.parameters.url).hostname;
            }
            catch {
                nodeItem.domain = getDomainBase(node.parameters.url);
            }
        }
        else if (node.type === Constants_1.HTTP_REQUEST_NODE_TYPE && node.typeVersion > 1) {
            const { authentication } = node.parameters;
            nodeItem.credential_type = {
                none: 'none',
                genericCredentialType: node.parameters.genericAuthType,
                predefinedCredentialType: node.parameters.nodeCredentialType,
            }[authentication];
            nodeItem.credential_set = node.credentials ? Object.keys(node.credentials).length > 0 : false;
            const { url } = node.parameters;
            nodeItem.domain_base = getDomainBase(url);
            nodeItem.domain_path = getDomainPath(url);
            nodeItem.method = node.parameters.requestMethod;
        }
        else if (node.type === Constants_1.WEBHOOK_NODE_TYPE) {
            webhookNodeNames.push(node.name);
        }
        else {
            try {
                const nodeType = nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
                if (nodeType) {
                    const nodeParameters = (0, NodeHelpers_1.getNodeParameters)(nodeType.description.properties, node.parameters, true, false, node);
                    if (nodeParameters) {
                        const keys = [
                            'operation',
                            'resource',
                            'mode',
                        ];
                        keys.forEach((key) => {
                            var _a;
                            if (nodeParameters.hasOwnProperty(key)) {
                                nodeItem[key] = (_a = nodeParameters[key]) === null || _a === void 0 ? void 0 : _a.toString();
                            }
                        });
                    }
                }
            }
            catch (e) {
                if (!(e instanceof Error && e.message.includes('Unrecognized node type'))) {
                    throw e;
                }
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.isCloudDeployment) === true) {
            if (node.type === Constants_1.OPENAI_LANGCHAIN_NODE_TYPE) {
                nodeItem.prompts =
                    (((_b = node.parameters) === null || _b === void 0 ? void 0 : _b.messages) || {}).values || [];
            }
            if (node.type === Constants_1.AGENT_LANGCHAIN_NODE_TYPE) {
                const prompts = {};
                if ((_c = node.parameters) === null || _c === void 0 ? void 0 : _c.text) {
                    prompts.text = node.parameters.text;
                }
                const nodeOptions = (_d = node.parameters) === null || _d === void 0 ? void 0 : _d.options;
                if (nodeOptions) {
                    const optionalMessagesKeys = [
                        'humanMessage',
                        'systemMessage',
                        'humanMessageTemplate',
                        'prefix',
                        'suffixChat',
                        'suffix',
                        'prefixPrompt',
                        'suffixPrompt',
                    ];
                    for (const key of optionalMessagesKeys) {
                        if (nodeOptions[key]) {
                            prompts[key] = nodeOptions[key];
                        }
                    }
                }
                if (Object.keys(prompts).length) {
                    nodeItem.prompts = prompts;
                }
            }
            if (node.type === Constants_1.CHAIN_SUMMARIZATION_LANGCHAIN_NODE_TYPE) {
                nodeItem.prompts = ((((_e = node.parameters) === null || _e === void 0 ? void 0 : _e.options) || {})
                    .summarizationMethodAndPrompts || {}).values;
            }
            if (Constants_1.LANGCHAIN_CUSTOM_TOOLS.includes(node.type)) {
                nodeItem.prompts = {
                    description: ((_f = node.parameters) === null || _f === void 0 ? void 0 : _f.description) || '',
                };
            }
        }
        nodeGraph.nodes[index.toString()] = nodeItem;
        nameIndices[node.name] = index.toString();
    });
    const getGraphConnectionItem = (startNode, connectionItem) => {
        return { start: nameIndices[startNode], end: nameIndices[connectionItem.node] };
    };
    Object.keys((_d = workflow.connections) !== null && _d !== void 0 ? _d : []).forEach((nodeName) => {
        var _a;
        const connections = (_a = workflow.connections) === null || _a === void 0 ? void 0 : _a[nodeName];
        if (!connections) {
            return;
        }
        Object.keys(connections).forEach((key) => {
            connections[key].forEach((element) => {
                (element !== null && element !== void 0 ? element : []).forEach((element2) => {
                    nodeGraph.node_connections.push(getGraphConnectionItem(nodeName, element2));
                });
            });
        });
    });
    return { nodeGraph, nameIndices, webhookNodeNames };
}
exports.generateNodesGraph = generateNodesGraph;
//# sourceMappingURL=TelemetryHelpers.js.map