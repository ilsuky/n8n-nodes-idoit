"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringExtensions = exports.SupportedHashAlgorithms = void 0;
const jssha_1 = __importDefault(require("jssha"));
const md5_1 = __importDefault(require("md5"));
const js_base64_1 = require("js-base64");
const title_case_1 = require("title-case");
const transliteration_1 = require("transliteration");
const expression_extension_error_1 = require("../errors/expression-extension.error");
exports.SupportedHashAlgorithms = [
    'md5',
    'sha1',
    'sha224',
    'sha256',
    'sha384',
    'sha512',
    'sha3',
];
const CURRENCY_REGEXP = /(\u004c\u0065\u006b|\u060b|\u0024|\u0192|\u20bc|\u0042\u0072|\u0042\u005a\u0024|\u0024\u0062|\u004b\u004d|\u0050|\u043b\u0432|\u0052\u0024|\u17db|\u00a5|\u20a1|\u006b\u006e|\u20b1|\u004b\u010d|\u006b\u0072|\u0052\u0044\u0024|\u00a3|\u20ac|\u00a2|\u0051|\u004c|\u0046\u0074|\u20b9|\u0052\u0070|\ufdfc|\u20aa|\u004a\u0024|\u20a9|\u20ad|\u0434\u0435\u043d|\u0052\u004d|\u20a8|\u20ae|\u004d\u0054|\u0043\u0024|\u20a6|\u0042\u002f\u002e|\u0047\u0073|\u0053\u002f\u002e|\u007a\u0142|\u006c\u0065\u0069|\u20bd|\u0414\u0438\u043d\u002e|\u0053|\u0052|\u0043\u0048\u0046|\u004e\u0054\u0024|\u0e3f|\u0054\u0054\u0024|\u20ba|\u20b4|\u0024\u0055|\u0042\u0073|\u20ab|\u005a\u0024)/gu;
const DOMAIN_EXTRACT_REGEXP = /^(?:(?:https?|ftp):\/\/)?(?:mailto:)?(?:\/\/)?((?:www\.)?(?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?]*)?(?:\?[^\s#]*)?(?:#[^\s]*)?$/i;
const DOMAIN_REGEXP = /^(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?]*)?(?:\?[^\s#]*)?(?:#[^\s]*)?$/i;
const EMAIL_REGEXP = /(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@(?<domain>(\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;
const URL_REGEXP_EXACT = /^(?:(?:https?|ftp):\/\/)(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?#]*)?(?:\?[^\s#]*)?(?=([^\s]+#.*)?)#?[^\s]*$/i;
const URL_REGEXP = /(?:(?:https?|ftp):\/\/)(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?#]*)?(?:\?[^\s#]*)?(?=([^\s]+#.*)?)#?[^\s]*/i;
const CHAR_TEST_REGEXP = /\p{L}/u;
const PUNC_TEST_REGEXP = /[!?.]/;
function hash(value, extraArgs) {
    var _a, _b;
    const algorithm = (_b = (_a = extraArgs[0]) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'md5';
    switch (algorithm) {
        case 'base64':
            return (0, js_base64_1.encode)(value);
        case 'md5':
            return (0, md5_1.default)(value);
        case 'sha1':
        case 'sha224':
        case 'sha256':
        case 'sha384':
        case 'sha512':
        case 'sha3':
            const variant = {
                sha1: 'SHA-1',
                sha224: 'SHA-224',
                sha256: 'SHA-256',
                sha384: 'SHA-384',
                sha512: 'SHA-512',
                sha3: 'SHA3-512',
            }[algorithm];
            return new jssha_1.default(variant, 'TEXT').update(value).getHash('HEX');
        default:
            throw new expression_extension_error_1.ExpressionExtensionError(`Unknown algorithm ${algorithm}. Available algorithms are: ${exports.SupportedHashAlgorithms.join()}, and Base64.`);
    }
}
function isEmpty(value) {
    return value === '';
}
function isNotEmpty(value) {
    return !isEmpty(value);
}
function length(value) {
    return value.length;
}
function removeMarkdown(value) {
    let output = value;
    try {
        output = output.replace(/^([\s\t]*)([*\-+]|\d\.)\s+/gm, '$1');
        output = output
            .replace(/\n={2,}/g, '\n')
            .replace(/~~/g, '')
            .replace(/`{3}.*\n/g, '');
        output = output
            .replace(/<[\w|\s|=|'|"|:|(|)|,|;|/|0-9|.|-]+[>|\\>]/g, '')
            .replace(/^[=-]{2,}\s*$/g, '')
            .replace(/\[\^.+?\](: .*?$)?/g, '')
            .replace(/\s{0,2}\[.*?\]: .*?$/g, '')
            .replace(/!\[.*?\][[(].*?[\])]/g, '')
            .replace(/\[(.*?)\][[(].*?[\])]/g, '$1')
            .replace(/>/g, '')
            .replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, '')
            .replace(/^#{1,6}\s*([^#]*)\s*(#{1,6})?/gm, '$1')
            .replace(/([*_]{1,3})(\S.*?\S)\1/g, '$2')
            .replace(/(`{3,})(.*?)\1/gm, '$2')
            .replace(/^-{3,}\s*$/g, '')
            .replace(/`(.+?)`/g, '$1')
            .replace(/\n{2,}/g, '\n\n');
    }
    catch (e) {
        return value;
    }
    return output;
}
function removeTags(value) {
    return value.replace(/<[^>]*>?/gm, '');
}
function toDate(value) {
    const date = new Date(Date.parse(value));
    if (date.toString() === 'Invalid Date') {
        throw new expression_extension_error_1.ExpressionExtensionError('cannot convert to date');
    }
    if (!/:/.test(value)) {
        date.setHours(0, 0, 0);
    }
    return date;
}
function urlDecode(value, extraArgs) {
    const [entireString = false] = extraArgs;
    if (entireString) {
        return decodeURI(value.toString());
    }
    return decodeURIComponent(value.toString());
}
function urlEncode(value, extraArgs) {
    const [entireString = false] = extraArgs;
    if (entireString) {
        return encodeURI(value.toString());
    }
    return encodeURIComponent(value.toString());
}
function toInt(value, extraArgs) {
    const [radix] = extraArgs;
    const int = parseInt(value.replace(CURRENCY_REGEXP, ''), radix);
    if (isNaN(int)) {
        throw new expression_extension_error_1.ExpressionExtensionError('cannot convert to integer');
    }
    return int;
}
function toFloat(value) {
    if (value.includes(',')) {
        throw new expression_extension_error_1.ExpressionExtensionError('cannot convert to float, expected . as decimal separator');
    }
    const float = parseFloat(value.replace(CURRENCY_REGEXP, ''));
    if (isNaN(float)) {
        throw new expression_extension_error_1.ExpressionExtensionError('cannot convert to float');
    }
    return float;
}
function quote(value, extraArgs) {
    const [quoteChar = '"'] = extraArgs;
    return `${quoteChar}${value
        .replace(/\\/g, '\\\\')
        .replace(new RegExp(`\\${quoteChar}`, 'g'), `\\${quoteChar}`)}${quoteChar}`;
}
function isNumeric(value) {
    if (value.includes(' '))
        return false;
    return !isNaN(value) && !isNaN(parseFloat(value));
}
function isUrl(value) {
    return URL_REGEXP_EXACT.test(value);
}
function isDomain(value) {
    return DOMAIN_REGEXP.test(value);
}
function isEmail(value) {
    const result = EMAIL_REGEXP.test(value);
    if (result && value.includes(' ')) {
        return false;
    }
    return result;
}
function toTitleCase(value) {
    return (0, title_case_1.titleCase)(value);
}
function replaceSpecialChars(value) {
    return (0, transliteration_1.transliterate)(value, { unknown: '?' });
}
function toSentenceCase(value) {
    let current = value.slice();
    let buffer = '';
    while (CHAR_TEST_REGEXP.test(current)) {
        const charIndex = current.search(CHAR_TEST_REGEXP);
        current =
            current.slice(0, charIndex) +
                current[charIndex].toLocaleUpperCase() +
                current.slice(charIndex + 1).toLocaleLowerCase();
        const puncIndex = current.search(PUNC_TEST_REGEXP);
        if (puncIndex === -1) {
            buffer += current;
            current = '';
            break;
        }
        buffer += current.slice(0, puncIndex + 1);
        current = current.slice(puncIndex + 1);
    }
    return buffer;
}
function toSnakeCase(value) {
    return value
        .toLocaleLowerCase()
        .replace(/[ \-]/g, '_')
        .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,.\/:;<=>?@\[\]^`{|}~]/g, '');
}
function extractEmail(value) {
    const matched = EMAIL_REGEXP.exec(value);
    if (!matched) {
        return undefined;
    }
    return matched[0];
}
function extractDomain(value) {
    var _a;
    if (isEmail(value)) {
        const matched = EMAIL_REGEXP.exec(value);
        if (!matched) {
            return undefined;
        }
        return (_a = matched.groups) === null || _a === void 0 ? void 0 : _a.domain;
    }
    const domainMatch = value.match(DOMAIN_EXTRACT_REGEXP);
    if (domainMatch) {
        return domainMatch[1];
    }
    return undefined;
}
function extractUrl(value) {
    const matched = URL_REGEXP.exec(value);
    if (!matched) {
        return undefined;
    }
    return matched[0];
}
removeMarkdown.doc = {
    name: 'removeMarkdown',
    description: 'Removes Markdown formatting from a string.',
    section: 'edit',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-removeMarkdown',
};
removeTags.doc = {
    name: 'removeTags',
    description: 'Removes tags, such as HTML or XML, from a string.',
    section: 'edit',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-removeTags',
};
toDate.doc = {
    name: 'toDate',
    description: 'Converts a string to a date.',
    section: 'cast',
    returnType: 'Date',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDate',
};
toFloat.doc = {
    name: 'toFloat',
    description: 'Converts a string to a decimal number.',
    section: 'cast',
    returnType: 'number',
    aliases: ['toDecimalNumber'],
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDecimalNumber',
};
toInt.doc = {
    name: 'toInt',
    description: 'Converts a string to an integer.',
    section: 'cast',
    returnType: 'number',
    args: [{ name: 'radix?', type: 'number' }],
    aliases: ['toWholeNumber'],
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toInt',
};
toSentenceCase.doc = {
    name: 'toSentenceCase',
    description: 'Formats a string to sentence case. Example: "This is a sentence".',
    section: 'case',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toSentenceCase',
};
toSnakeCase.doc = {
    name: 'toSnakeCase',
    description: 'Formats a string to snake case. Example: "this_is_snake_case".',
    section: 'case',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toSnakeCase',
};
toTitleCase.doc = {
    name: 'toTitleCase',
    description: 'Formats a string to title case. Example: "This Is a Title". Will not change already uppercase letters to prevent losing information from acronyms and trademarks such as iPhone or FAANG.',
    section: 'case',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toTitleCase',
};
urlEncode.doc = {
    name: 'urlEncode',
    description: 'Encodes a string to be used/included in a URL.',
    section: 'edit',
    args: [{ name: 'entireString?', type: 'boolean' }],
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-urlEncode',
};
urlDecode.doc = {
    name: 'urlDecode',
    description: 'Decodes a URL-encoded string. It decodes any percent-encoded characters in the input string, and replaces them with their original characters.',
    section: 'edit',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-urlDecode',
};
replaceSpecialChars.doc = {
    name: 'replaceSpecialChars',
    description: 'Replaces non-ASCII characters in a string with an ASCII representation.',
    section: 'edit',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-replaceSpecialChars',
};
length.doc = {
    name: 'length',
    section: 'query',
    hidden: true,
    description: 'Returns the character count of a string.',
    returnType: 'number',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings',
};
isDomain.doc = {
    name: 'isDomain',
    description: 'Checks if a string is a domain.',
    section: 'validation',
    returnType: 'boolean',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isDomain',
};
isEmail.doc = {
    name: 'isEmail',
    description: 'Checks if a string is an email.',
    section: 'validation',
    returnType: 'boolean',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isEmail',
};
isNumeric.doc = {
    name: 'isNumeric',
    description: 'Checks if a string only contains digits.',
    section: 'validation',
    returnType: 'boolean',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isNumeric',
};
isUrl.doc = {
    name: 'isUrl',
    description: 'Checks if a string is a valid URL.',
    section: 'validation',
    returnType: 'boolean',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isUrl',
};
isEmpty.doc = {
    name: 'isEmpty',
    description: 'Checks if a string is empty.',
    section: 'validation',
    returnType: 'boolean',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isEmpty',
};
isNotEmpty.doc = {
    name: 'isNotEmpty',
    description: 'Checks if a string has content.',
    section: 'validation',
    returnType: 'boolean',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isNotEmpty',
};
extractEmail.doc = {
    name: 'extractEmail',
    description: 'Extracts an email from a string. Returns undefined if none is found.',
    section: 'edit',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractEmail',
};
extractDomain.doc = {
    name: 'extractDomain',
    description: 'Extracts a domain from a string containing a valid URL. Returns undefined if none is found.',
    section: 'edit',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractDomain',
};
extractUrl.doc = {
    name: 'extractUrl',
    description: 'Extracts a URL from a string. Returns undefined if none is found.',
    section: 'edit',
    returnType: 'string',
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractUrl',
};
hash.doc = {
    name: 'hash',
    description: 'Returns a string hashed with the given algorithm. Default algorithm is `md5`.',
    section: 'edit',
    returnType: 'string',
    args: [{ name: 'algo?', type: 'Algorithm' }],
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-hash',
};
quote.doc = {
    name: 'quote',
    description: 'Returns a string wrapped in the quotation marks. Default quotation is `"`.',
    section: 'edit',
    returnType: 'string',
    args: [{ name: 'mark?', type: 'string' }],
    docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-quote',
};
const toDecimalNumber = toFloat.bind({});
toDecimalNumber.doc = { ...toFloat.doc, hidden: true };
const toWholeNumber = toInt.bind({});
toWholeNumber.doc = { ...toInt.doc, hidden: true };
exports.stringExtensions = {
    typeName: 'String',
    functions: {
        hash,
        removeMarkdown,
        removeTags,
        toDate,
        toDecimalNumber,
        toFloat,
        toInt,
        toWholeNumber,
        toSentenceCase,
        toSnakeCase,
        toTitleCase,
        urlDecode,
        urlEncode,
        quote,
        replaceSpecialChars,
        length,
        isDomain,
        isEmail,
        isNumeric,
        isUrl,
        isEmpty,
        isNotEmpty,
        extractEmail,
        extractDomain,
        extractUrl,
    },
};
//# sourceMappingURL=StringExtensions.js.map