"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFieldType = exports.tryToParseUrl = exports.tryToParseObject = exports.tryToParseArray = exports.tryToParseTime = exports.tryToParseDateTime = exports.tryToParseBoolean = exports.tryToParseString = exports.tryToParseNumber = void 0;
const luxon_1 = require("luxon");
const isObject_1 = __importDefault(require("lodash/isObject"));
const errors_1 = require("./errors");
const tryToParseNumber = (value) => {
    const isValidNumber = !isNaN(Number(value));
    if (!isValidNumber) {
        throw new errors_1.ApplicationError('Failed to parse value to number', { extra: { value } });
    }
    return Number(value);
};
exports.tryToParseNumber = tryToParseNumber;
const tryToParseString = (value) => {
    if (typeof value === 'object')
        return JSON.stringify(value);
    if (typeof value === 'undefined')
        return '';
    if (typeof value === 'string' ||
        typeof value === 'bigint' ||
        typeof value === 'boolean' ||
        typeof value === 'number') {
        return value.toString();
    }
    return String(value);
};
exports.tryToParseString = tryToParseString;
const tryToParseBoolean = (value) => {
    if (typeof value === 'boolean') {
        return value;
    }
    if (typeof value === 'string' && ['true', 'false'].includes(value.toLowerCase())) {
        return value.toLowerCase() === 'true';
    }
    if (!(typeof value === 'string' && value.trim() === '')) {
        const num = Number(value);
        if (num === 0) {
            return false;
        }
        else if (num === 1) {
            return true;
        }
    }
    throw new errors_1.ApplicationError('Failed to parse value as boolean', {
        extra: { value },
    });
};
exports.tryToParseBoolean = tryToParseBoolean;
const tryToParseDateTime = (value) => {
    if (value instanceof luxon_1.DateTime && value.isValid) {
        return value;
    }
    if (value instanceof Date) {
        const fromJSDate = luxon_1.DateTime.fromJSDate(value);
        if (fromJSDate.isValid) {
            return fromJSDate;
        }
    }
    const dateString = String(value).trim();
    const isoDate = luxon_1.DateTime.fromISO(dateString, { setZone: true });
    if (isoDate.isValid) {
        return isoDate;
    }
    const httpDate = luxon_1.DateTime.fromHTTP(dateString, { setZone: true });
    if (httpDate.isValid) {
        return httpDate;
    }
    const rfc2822Date = luxon_1.DateTime.fromRFC2822(dateString, { setZone: true });
    if (rfc2822Date.isValid) {
        return rfc2822Date;
    }
    const sqlDate = luxon_1.DateTime.fromSQL(dateString, { setZone: true });
    if (sqlDate.isValid) {
        return sqlDate;
    }
    const parsedDateTime = luxon_1.DateTime.fromMillis(Date.parse(dateString));
    if (parsedDateTime.isValid) {
        return parsedDateTime;
    }
    throw new errors_1.ApplicationError('Value is not a valid date', { extra: { dateString } });
};
exports.tryToParseDateTime = tryToParseDateTime;
const tryToParseTime = (value) => {
    const isTimeInput = /^\d{2}:\d{2}(:\d{2})?((\-|\+)\d{4})?((\-|\+)\d{1,2}(:\d{2})?)?$/s.test(String(value));
    if (!isTimeInput) {
        throw new errors_1.ApplicationError('Value is not a valid time', { extra: { value } });
    }
    return String(value);
};
exports.tryToParseTime = tryToParseTime;
const tryToParseArray = (value) => {
    try {
        if (typeof value === 'object' && Array.isArray(value)) {
            return value;
        }
        let parsed;
        try {
            parsed = JSON.parse(String(value));
        }
        catch (e) {
            parsed = JSON.parse(String(value).replace(/'/g, '"'));
        }
        if (!Array.isArray(parsed)) {
            throw new errors_1.ApplicationError('Value is not a valid array', { extra: { value } });
        }
        return parsed;
    }
    catch (e) {
        throw new errors_1.ApplicationError('Value is not a valid array', { extra: { value } });
    }
};
exports.tryToParseArray = tryToParseArray;
const tryToParseObject = (value) => {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
        return value;
    }
    try {
        const o = JSON.parse(String(value));
        if (typeof o !== 'object' || Array.isArray(o)) {
            throw new errors_1.ApplicationError('Value is not a valid object', { extra: { value } });
        }
        return o;
    }
    catch (e) {
        throw new errors_1.ApplicationError('Value is not a valid object', { extra: { value } });
    }
};
exports.tryToParseObject = tryToParseObject;
const tryToParseUrl = (value) => {
    if (typeof value === 'string' && !value.includes('://')) {
        value = `http://${value}`;
    }
    const urlPattern = /^(https?|ftp|file):\/\/\S+|www\.\S+/;
    if (!urlPattern.test(String(value))) {
        throw new errors_1.ApplicationError(`The value "${String(value)}" is not a valid url.`, {
            extra: { value },
        });
    }
    return String(value);
};
exports.tryToParseUrl = tryToParseUrl;
const validateFieldType = (fieldName, value, type, options = {}) => {
    var _a, _b, _c;
    if (value === null || value === undefined)
        return { valid: true };
    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;
    const valueOptions = (_b = options.valueOptions) !== null && _b !== void 0 ? _b : [];
    const parseStrings = (_c = options.parseStrings) !== null && _c !== void 0 ? _c : false;
    const defaultErrorMessage = `'${fieldName}' expects a ${type} but we got '${String(value)}'`;
    switch (type.toLowerCase()) {
        case 'string': {
            if (!parseStrings)
                return { valid: true, newValue: value };
            try {
                if (strict && typeof value !== 'string') {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseString)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'number': {
            try {
                if (strict && typeof value !== 'number') {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseNumber)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'boolean': {
            try {
                if (strict && typeof value !== 'boolean') {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseBoolean)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'datetime': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseDateTime)(value) };
            }
            catch (e) {
                const luxonDocsURL = 'https://moment.github.io/luxon/api-docs/index.html#datetimefromformat';
                const errorMessage = `${defaultErrorMessage} <br/><br/> Consider using <a href="${luxonDocsURL}" target="_blank"><code>DateTime.fromFormat</code></a> to work with custom date formats.`;
                return { valid: false, errorMessage };
            }
        }
        case 'time': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseTime)(value) };
            }
            catch (e) {
                return {
                    valid: false,
                    errorMessage: `'${fieldName}' expects time (hh:mm:(:ss)) but we got '${String(value)}'.`,
                };
            }
        }
        case 'object': {
            try {
                if (strict && !(0, isObject_1.default)(value)) {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseObject)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'array': {
            if (strict && !Array.isArray(value)) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
            try {
                return { valid: true, newValue: (0, exports.tryToParseArray)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'options': {
            const validOptions = valueOptions.map((option) => option.value).join(', ');
            const isValidOption = valueOptions.some((option) => option.value === value);
            if (!isValidOption) {
                return {
                    valid: false,
                    errorMessage: `'${fieldName}' expects one of the following values: [${validOptions}] but we got '${String(value)}'`,
                };
            }
            return { valid: true, newValue: value };
        }
        case 'url': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseUrl)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        default: {
            return { valid: true, newValue: value };
        }
    }
};
exports.validateFieldType = validateFieldType;
//# sourceMappingURL=TypeValidation.js.map